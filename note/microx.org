* Micro Execution

** Overview

Micro Execution is another VM based unit testing approach which allows you to test code fragment with out full libraries/code base.

Primarily used for catching memory bugs since other unit-test bugs might be difficult to specified.

** Methodlogy

TL;DR. A VM hijacks all memory operations and makes policy based on memop. E.g. we can have following policy
to deal with uninitialized memory:
#+BEGIN_SRC text
An input is deﬁned as any value read from an uninitialized function argument,
or from a dereference of a previous input used as an address (recursive deﬁnition). (*)
#+END_SRC

To be more specific, look at following code:
#+BEGIN_SRC c
void foo(char *p) { // p is a 4-byte input
  char v = *p; // *p is a 1-byte input
  return;
}
#+END_SRC

Since p is potentially unknown, we can first generate random value for p.
And it's later detected as dereference pointer, so we generate one byte for (char c).

** Implementation

TL;DR. it hooks memory operation on VM like QEMU via code instrument.
To validate memory access, it will check whether the address is in stack/generated location (return true)
or unknown location (return false).
On address generation case, the address is stored in another chunk of address called *ExternalMemory*
which will be filled with some random bytes.

MicroX provides 5 input-gen modes: zero mode (all input are zeros), random mode (random input, except requested data
which matches pointer length will be used by malloc for future address handling), file mode
(read from files generated by user which are important for replay purpose), process-dump mode
(read value generating by some running processes), and SAGE mode (basically symbolic execution mode).

** Other thoughts?

The paper is quite vague, but it does give us a novel insight about using heuristic memory-op based methods
to generate input. But the paper itself does not talk too much about dirty implementations...
Dealing global variables/variable size structure is particularly note-worthy.

Recommend to read MicroX from lifting-bits or Primus from Bap to unveil more details.

I think the approach is only useful when you have enough robust memory generation policies to avoid false positive.
Otherwise it could be nightmare. In addition, using it with symbolic executor might be efficient
(VM has more accurate data meanwhile SMT faces less constraints). Could try it on CTF challenges or some small binaries.
An interesting scenario of MicroX could be modelling dynamic libraries' behavior & bugs because functions are less coupling.
